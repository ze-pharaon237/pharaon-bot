"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const db_1 = __importDefault(require("../lib/db"));
const moduleCategory_1 = require("../lib/moduleCategory");
const input_sanitization_1 = __importDefault(require("../sidekick/input-sanitization"));
const message_type_1 = require("../sidekick/message-type");
const vote = db_1.default.vote;
const fs_1 = __importDefault(require("fs"));
/// display command
function displayVote(_vote, BotsApp) {
    var sender = "@" + _vote.creatorId.split("@")[0];
    var text = "*Vote creator :* \n" + sender + "\n\n" + "*label :* \n" + _vote.label + "\n";
    var buttons = [];
    var i = 1;
    buttons.push({ buttonId: 'id1', buttonText: { displayText: " " }, type: 1 });
    for (var str of _vote.choice) {
        if (str.length > 0) {
            buttons.push({ buttonId: 'id1', buttonText: { displayText: ".vote " + vote.CHOOSE + " " + _vote.voteId + " " + str }, type: 1 });
        }
        i++;
    }
    console.log(buttons);
    const buttonMessage = {
        text: text,
        buttons: buttons,
        footer: "Generated by PharaonBot",
        headerType: 1
    };
    return buttonMessage;
}
function displayResult(_vote, BotsApp) {
    var sender = "@" + _vote.creatorId.split("@")[0];
    var text = "*Result of vote :" + _vote.voteId + "* \n" + "\n\n";
    text += "date : " + _vote.date + "\n";
    text += "*Member vote count:* " + _vote.memberVote.length + "/" + BotsApp.groupMembers.length + "\n\n";
    text += "*Details :* \n";
    for (var str of _vote.choice) {
        var x = 0;
        for (var memberVote of _vote.memberVote) {
            if (isValidMemberVoteChoice(str, memberVote.choice)) {
                x++;
            }
        }
        text += "-" + str + ":" + x + "/" + _vote.memberVote.length + "\n";
    }
    return text;
}
/// command function
function JSON_createVote(_label, _creator, _choice, _group) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            let obj = yield readFile();
            /// create or get groupe
            let groupe;
            let existIndex = isGroupExist(obj.group, _group);
            if (existIndex >= 0) {
                groupe = obj.group[existIndex];
            }
            else {
                groupe = new Group();
                groupe.groupId = _group;
                obj.group.push(groupe);
            }
            /// create vote
            let vote = new Vote();
            if (groupe.voteList.length > 0) {
                vote.voteId = groupe.voteList[groupe.voteList.length - 1].voteId + 1;
            }
            else {
                vote.voteId = 1;
            }
            vote.date = new Date().toLocaleString();
            vote.label = _label;
            vote.creatorId = _creator;
            vote.choice = _choice;
            groupe.voteList.push(vote);
            yield writeFile(obj);
            return vote;
        }
        catch (error) {
            console.log(error);
            return null;
        }
    });
}
function JSON_addMemberChoice(_group, _vote, _memberId, _choice) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            let obj = yield readFile();
            // get group
            let groupe;
            let groupExistIndex = isGroupExist(obj.group, _group);
            if (groupExistIndex >= 0) {
                groupe = obj.group[groupExistIndex];
            }
            else {
                return "Unknow vote, maybe vote are delete by the administrator or my owner";
            }
            /// get vote
            let vote;
            let voteExistIndex = isVoteExist(groupe.voteList, _vote);
            if (voteExistIndex >= 0) {
                vote = groupe.voteList[voteExistIndex];
                console.log(vote);
            }
            else {
                return "Unknow vote, maybe vote are delete by the administrator or my owner";
            }
            //verify choice
            if (!isMemberVoteChoiceExist(vote.choice, _choice)) {
                console.log("'" + _choice + "'");
                return _choice + " is not a valid choice !";
            }
            // add member vote
            let memberVote;
            let memberVoteExistIndex = isMemberVoteExist(vote.memberVote, _memberId);
            if (memberVoteExistIndex >= 0) {
                memberVote = vote.memberVote[memberVoteExistIndex];
                memberVote.choice = _choice;
                yield writeFile(obj);
                return "We are *change* your vote : " + _choice;
            }
            else {
                memberVote = new MemberVote(_memberId, _choice);
                vote.memberVote.push(memberVote);
                yield writeFile(obj);
                return "We are *save* your vote : " + _choice;
            }
        }
        catch (error) {
            console.log(error);
            return "Unknow error, contact my owner";
        }
    });
}
function readFile() {
    return __awaiter(this, void 0, void 0, function* () {
        let obj = new Obj();
        yield fs_1.default.promises.readFile(vote.FILE, "utf8").then((data) => {
            if (data.length > 0) {
                obj = JSON.parse(data);
            }
            else {
                console.log("Empty list");
            }
        }).catch(() => {
            console.log("err");
        });
        return obj;
    });
}
function writeFile(obj) {
    return __awaiter(this, void 0, void 0, function* () {
        let value = false;
        yield fs_1.default.promises.writeFile(vote.FILE, JSON.stringify(obj), "utf8")
            .then(() => {
            value = true;
        })
            .catch((err) => {
            console.log("err");
        });
        return value;
    });
}
/// verification function
function isGroupExist(_groupe, id) {
    for (var i = 0; i < _groupe.length; i++) {
        if (_groupe[i].groupId === id)
            return i;
    }
    return -1;
}
function isVoteExist(_vote, id) {
    for (var i = 0; i < _vote.length; i++) {
        if (_vote[i].voteId == id)
            return i;
    }
    return -1;
}
function isMemberVoteExist(_memberVote, memberId) {
    for (var i = 0; i < _memberVote.length; i++) {
        if (_memberVote[i].memberId === memberId)
            return i;
    }
    return -1;
}
function isMemberVoteChoiceExist(_choice, choiceValue) {
    for (var i = 0; i < _choice.length; i++) {
        console.log("\n");
        console.log(_choice[i]);
        console.log(choiceValue);
        console.log(_choice[i].length);
        console.log(_choice[i].split(" ").length);
        console.log(choiceValue.length);
        if (isValidMemberVoteChoice(_choice[i], choiceValue)) {
            return true;
        }
    }
    return false;
}
function isValidMemberVoteChoice(item, choice) {
    for (let str of choice.split("")) {
        if (!item.includes(str)) {
            return false;
        }
    }
    if (item.length == (item.split(" ").length - 1 + choice.length)) {
        return true;
    }
    else {
        return false;
    }
}
/// class
class Obj {
    constructor() {
        this.group = [];
    }
}
class Group {
    constructor() {
        this.groupId = "";
        this.voteList = [];
    }
}
class Vote {
    constructor() {
        this.voteId = 0;
        this.creatorId = "";
        this.label = "";
        this.date = "";
        this.choice = [];
        this.memberVote = [];
    }
}
class MemberVote {
    constructor(mid, ch) {
        this.memberId = "";
        this.choice = "";
        this.memberId = mid;
        this.choice = ch;
    }
}
module.exports = {
    name: "vote",
    description: vote.DESCRIPTION,
    extendedDescription: vote.EXTENDED_DESCRIPTION,
    demo: { isEnabled: false },
    category: moduleCategory_1.ModuleCategory.game,
    handle(client, chat, BotsApp, args) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (!BotsApp.isGroup) {
                    client.sendMessage(BotsApp.chatId, db_1.default.general.NOT_A_GROUP, message_type_1.MessageType.text).catch(err => input_sanitization_1.default.handleError(err, client, BotsApp));
                    return;
                }
                yield client.getGroupMetaData(BotsApp.chatId, BotsApp);
                if (args[0] === vote.CREATE) {
                    console.log(vote.CREATE);
                    if (!BotsApp.isSenderGroupAdmin) {
                        client.sendMessage(BotsApp.chatId, db_1.default.general.ADMIN_PERMISSION, message_type_1.MessageType.text).catch(err => input_sanitization_1.default.handleError(err, client, BotsApp));
                        return;
                    }
                    //syntaxe : .vote create vote_message ///choix1 / choix2 / choix3 ...
                    let syntax = "";
                    for (var index = 1; index < args.length; index++) {
                        syntax += args[index] + " ";
                    }
                    let syntaxTab = syntax.split("///");
                    if (syntaxTab[0].length == 0 || syntaxTab[1].length == 0) {
                        client.sendMessage(BotsApp.chatId, "A part can't have 0 character.", message_type_1.MessageType.text).catch(err => input_sanitization_1.default.handleError(err, client, BotsApp));
                        return;
                    }
                    else if (syntaxTab.length > 2) {
                        client.sendMessage(BotsApp.chatId, "The create vote syntaxe can't have more that 2 part ! (part1 /// part2)", message_type_1.MessageType.text).catch(err => input_sanitization_1.default.handleError(err, client, BotsApp));
                        return;
                    }
                    else if (syntaxTab[1].split("/").length > 2) {
                        client.sendMessage(BotsApp.chatId, "You can make only 2 choices !", message_type_1.MessageType.text).catch(err => input_sanitization_1.default.handleError(err, client, BotsApp));
                        return;
                    }
                    yield client.getGroupMetaData(BotsApp.chatId, BotsApp);
                    let label = syntaxTab[0];
                    let creator = BotsApp.sender;
                    let choice = syntaxTab[1].split("/");
                    let group = BotsApp.groupId;
                    let result = yield JSON_createVote(label, creator, choice, group);
                    if (result) {
                        let members = [];
                        for (var i = 0; i < BotsApp.groupMembers.length; i++) {
                            members[i] = BotsApp.groupMembers[i].id;
                        }
                        client.sendMessage(BotsApp.chatId, displayVote(result, BotsApp), message_type_1.MessageType.buttonsMessage, {
                            contextInfo: {
                                mentionedJid: members,
                            }
                        }).catch(err => input_sanitization_1.default.handleError(err, client, BotsApp));
                        return;
                    }
                    else {
                        client.sendMessage(BotsApp.chatId, "Unknow error, please contact my owner !", message_type_1.MessageType.text).catch(err => input_sanitization_1.default.handleError(err, client, BotsApp));
                        return;
                    }
                }
                else if (args[0] === vote.CHOOSE) {
                    console.log(vote.CHOOSE);
                    if (args.length < 3) {
                        client.sendMessage(BotsApp.chatId, "Wrong command, try .help vote !!!", message_type_1.MessageType.text).catch(err => input_sanitization_1.default.handleError(err, client, BotsApp));
                        return;
                    }
                    else {
                        let voteId = +args[1];
                        let choice = "";
                        for (var i = 2; i < args.length; i++) {
                            choice += args[i];
                        }
                        var result = yield JSON_addMemberChoice(BotsApp.groupId, voteId, BotsApp.sender, choice);
                        client.sendMessage(BotsApp.chatId, result, message_type_1.MessageType.text).catch(err => input_sanitization_1.default.handleError(err, client, BotsApp));
                        return;
                    }
                }
                else if (args[0] === vote.LIST) {
                    console.log(vote.LIST);
                    if (!BotsApp.isSenderGroupAdmin) {
                        client.sendMessage(BotsApp.chatId, db_1.default.general.ADMIN_PERMISSION, message_type_1.MessageType.text).catch(err => input_sanitization_1.default.handleError(err, client, BotsApp));
                        return;
                    }
                    const obj = yield readFile();
                    var message = "";
                    let members = [];
                    // get group
                    let groupe;
                    let groupExistIndex = isGroupExist(obj.group, BotsApp.groupId);
                    if (groupExistIndex >= 0) {
                        groupe = obj.group[groupExistIndex];
                        if (groupe.voteList.length > 0) {
                            for (var tab of groupe.voteList) {
                                if (!members.includes(tab.creatorId)) {
                                    members.push(tab.creatorId);
                                }
                                message += "Â°" + tab.voteId + " - " + tab.date + " : @" + tab.creatorId.split("@")[0] + " \n" + "*Vote :* " + tab.label + " \n\n";
                            }
                        }
                        else {
                            message = "Empty";
                        }
                    }
                    else {
                        message = "Empty";
                    }
                    client.sendMessage(BotsApp.chatId, message, message_type_1.MessageType.text, {
                        contextInfo: {
                            mentionedJid: members,
                        }
                    }).catch(err => input_sanitization_1.default.handleError(err, client, BotsApp));
                    return;
                }
                else if (args[0] === vote.SHOW) {
                    console.log(vote.SHOW);
                    if (!BotsApp.isSenderGroupAdmin) {
                        client.sendMessage(BotsApp.chatId, db_1.default.general.ADMIN_PERMISSION, message_type_1.MessageType.text).catch(err => input_sanitization_1.default.handleError(err, client, BotsApp));
                        return;
                    }
                    if (args.length < 2) {
                        client.sendMessage(BotsApp.chatId, "Wrong command, try .help vote !!!", message_type_1.MessageType.text).catch(err => input_sanitization_1.default.handleError(err, client, BotsApp));
                        return;
                    }
                    else {
                        const obj = yield readFile();
                        let voteId = +args[1];
                        // get group
                        let groupe;
                        let groupExistIndex = isGroupExist(obj.group, BotsApp.groupId);
                        if (groupExistIndex >= 0) {
                            groupe = obj.group[groupExistIndex];
                        }
                        else {
                            client.sendMessage(BotsApp.chatId, "Unknow vote, maybe vote are delete by the administrator or my owner", message_type_1.MessageType.text).catch(err => input_sanitization_1.default.handleError(err, client, BotsApp));
                            return;
                        }
                        for (var tab of groupe.voteList) {
                            if (tab.voteId == voteId) {
                                client.sendMessage(BotsApp.chatId, displayVote(tab, BotsApp), message_type_1.MessageType.buttonsMessage, {
                                    contextInfo: {
                                        mentionedJid: [tab.creatorId],
                                    }
                                }).catch(err => input_sanitization_1.default.handleError(err, client, BotsApp));
                                return;
                            }
                        }
                        client.sendMessage(BotsApp.chatId, "Unknow vote, maybe vote are delete by the administrator or my owner", message_type_1.MessageType.text).catch(err => input_sanitization_1.default.handleError(err, client, BotsApp));
                        return;
                    }
                }
                else if (args[0] === vote.RESULT) {
                    console.log(vote.RESULT);
                    if (!BotsApp.isSenderGroupAdmin) {
                        client.sendMessage(BotsApp.chatId, db_1.default.general.ADMIN_PERMISSION, message_type_1.MessageType.text).catch(err => input_sanitization_1.default.handleError(err, client, BotsApp));
                        return;
                    }
                    if (args.length < 2) {
                        client.sendMessage(BotsApp.chatId, "Wrong command, try .help vote !!!", message_type_1.MessageType.text).catch(err => input_sanitization_1.default.handleError(err, client, BotsApp));
                        return;
                    }
                    else {
                        const obj = yield readFile();
                        let voteId = +args[1];
                        // get group
                        let groupe;
                        let groupExistIndex = isGroupExist(obj.group, BotsApp.groupId);
                        if (groupExistIndex >= 0) {
                            groupe = obj.group[groupExistIndex];
                        }
                        else {
                            client.sendMessage(BotsApp.chatId, "Unknow vote, maybe vote are delete by the administrator or my owner", message_type_1.MessageType.text).catch(err => input_sanitization_1.default.handleError(err, client, BotsApp));
                            return;
                        }
                        for (var tab of groupe.voteList) {
                            if (tab.voteId == voteId) {
                                client.sendMessage(BotsApp.chatId, displayResult(tab, BotsApp), message_type_1.MessageType.text).catch(err => input_sanitization_1.default.handleError(err, client, BotsApp));
                                return;
                            }
                        }
                        client.sendMessage(BotsApp.chatId, "Unknow vote, maybe vote are delete by the administrator or my owner", message_type_1.MessageType.text).catch(err => input_sanitization_1.default.handleError(err, client, BotsApp));
                        return;
                    }
                }
                else {
                    client.sendMessage(BotsApp.chatId, "Unknow command, try .help vote !", message_type_1.MessageType.text).catch(err => input_sanitization_1.default.handleError(err, client, BotsApp));
                    return;
                }
            }
            catch (err) {
                yield input_sanitization_1.default.handleError(err, client, BotsApp);
            }
        });
    },
};
//# sourceMappingURL=vote.js.map